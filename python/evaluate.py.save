#!/usr/bin/env python

import os
import re
import sys
import subprocess
import argparse
from multiprocessing import Pool

'''Script that produces the Smatch output for CAMR, Boxer and Seq2seq produced AMRs'''

parser = argparse.ArgumentParser()
parser.add_argument('-g', required=True, type=str, help="Folder with gold AMR files")
parser.add_argument('-eval_file', default = 'unnamed', type=str, help="Evaluation file")
parser.add_argument('-exp_name', required = True, type=str, help="Name of experiment")
parser.add_argument('-mx', required=False, type=int, default = 4, help="Number of maxthreads")
parser.add_argument('-rs', required=False, type=int, default = 4, help="Number of restarts for smatch")
parser.add_argument('-train_size', required=False, type=int, default = 33248 , help="Train size")
parser.add_argument('-range_sen', nargs='+', type=int, default = [], help ='Range of sentence length [min max]')
parser.add_argument('-range_words', nargs='+', type=int, default = [], help ='Set range of words instead of chars [min max]')
parser.add_argument('-roots_to_check', required = True, help = 'Root folder to check for output results')

args = parser.parse_args()

			
def prepare_data(ids):
	dirs_to_check = os.walk(args.roots_to_check).next()[1]
	
	#ids = ['.seq.amr.restore','.seq.amr.restore.wiki', '.seq.amr.restore.wiki.coref']
	ids = ['.seq.amr.restore','.seq.amr.restore.wiki', '.seq.amr.restore.coref']
	
	model_type = []
	for fol in dirs_to_check:
		for idx, ident in enumerate(ids):
			train_inst = fol.split('-')[-1]
			ep_num = round(float(train_inst) / float(args.train_size),0)
			
			if 'wiki' and 'coref' in ident:
				m_type = '{0} epochs (wiki + coref)'.format(ep_num)
			elif 'wiki' in ident:		
				m_type = '{0} epochs (wiki)'.format(ep_num)
			else:
				m_type = '{0} epochs'.format(ep_num)		
			
			model_type.append(m_type)
		
	gold_input = args.g
	gold_ids, gold_files = get_gold_ids(gold_input)
	res_dict = create_res_dict(model_type)	
	return model_type, gold_ids, gold_files, res_dict, dirs_to_check	


def get_gold_ids(root):
	gold_ids = []
	gold_files = []
	for r, d, files in os.walk(root):
		for f in files:
			if '.txt' in f:
				gold_ids.append(f.split('-')[6].split('.')[0])
				gold_files.append(f)
	return gold_ids, gold_files		


def create_res_dict(gold_ids):
	res_dict = {}
	for idn in gold_ids:
		res_dict[idn] = []
	
	return res_dict	


def get_gold_file(ident, gold_files):
	for f in gold_files:
		if ident in f:
			return f
	
	raise ValueError('No matching file found')		


def do_smatch(os_call, range_check):
	'''Runs the smatch OS call'''
	
	output = subprocess.check_output(os_call, shell=True)
	f_score = output.split()[-1]		# get F-score from output
	num_sen = output.split()[-4]
	
	if range_check:
		skipped_sen = output.split()[-7]
		processed_sen = int(total_sen) - int(skipped_sen)
		print 'Skipped sentences for {0} : {1} out of {4} (range {2}-{3})'.format(f.split('-')[-1].replace('.txt',''), skipped_sen, args.range_words[0], args.range_words[1], total_sen)
		return f_score, processed_sen
	else:	
		return f_score, num_sen


def evaluate(entry, ident, model, gold_ids, gold_files, res_dict):
	'''Will print smatch scores for Seq2seq checkpoints'''

	one_line = '--one_line'
	for root, dirs, files in os.walk(entry):
		for f in files:
			if f!= [] and f.endswith(ident):			# sometimes rubbish files in there, only find the file with the produced AMR
				for idn in gold_ids:					# check if it matches with a file in the gold map
					if idn in f:
						produced_f = os.path.join(root,f)
						if os.path.getsize(produced_f) > 0:
							gold_f = os.path.join(args.g, get_gold_file(idn, gold_files))
							
							if not args.range_sen and not args.range_words: # the normal output
					os_call = 'python ~/Documents/amr_Rik/Seq2seq/src/python/smatch_2.0.2/smatch.py -r {3} {2} -f {0} {1}'.format(produced_f, gold_f, one_line, args.rs)
								f_score, num_sen = do_smatch(os_call, False)
								res_dict[model].append([idn, f_score, int(num_sen)])
							
							elif args.range_words and not args.range_sen:		#only calculate smatch for sentences with certain word range
								os_call = 'python ~/Documents/amr_Rik/Seq2seq/src/python/smatch_2.0.2/smatch_max_length.py -w1 {3} -w2 {4} -r {5} {2} -f {0} {1}'.format(produced_f, gold_f, one_line, args.range_words[0], args.range_words[1], args.rs)	
								f_score, processed_sen = do_smatch(os_call, True)
								res_dict[model].append([idn, f_score, processed_sen])
							
							elif args.range_sen and not args.range_words:			# only calculate smatch score for sentences within a certain character range
								os_call = 'python ~/Documents/amr_Rik/Seq2seq/src/python/smatch_2.0.2/smatch_max_length.py -b1 {3} -b2 {4} -r {5} {2} -f {0} {1}'.format(produced_f, gold_f, one_line, args.range_sen[0], args.range_sen[1], args.rs)	
								f_score, processed_sen = do_smatch(os_call, True)
								res_dict[model].append([idn, f_score, processed_sen])
							else:
								raise ValueError("Don't do both range_sen and range_words")
						elif 'wiki' not in produced_f:
							print produced_f			
		break				
	return res_dict					
		
						
def fix_res_list(all_res):
	return_res = []
	for idx in range(len(all_res[0])):
		return_res.append("\t".join(all_res[0][idx]) + '\t' +  "\t".join(all_res[1][idx]))
	
	return return_res	

def add_average(d):
	for key in d:
		total_f, total_sen, did_item = 0, 0, False
		for item in d[key]:
			did_item = True
			total_sen += item[2]
			total_f += float(item[2]) * float(item[1])
		if did_item:
			avg_f = round(float(total_f) / float(total_sen),3)
			d[key].append(['avg',str(avg_f),str(total_sen)])
		else:
			d[key].append(['avg','',''])	
	
	return d	

def print_nice_output(res_dict, gold_ids, model_type):
	gold_ids.append('avg')		#add for average
	print '\nResults for', args.exp_name +':\n'
	print '\n\t\t\t\t' + "\t".join(gold_ids).replace('consensus','consen')  # last replace for nicer printing
	res_list = [[],[],[]]
	
	res_dict = add_average(res_dict)
	
	print_list = []
	
	for m in model_type:
		num_tabs = int(((8*4) - len(m)) / 8) 
		print_l = m + num_tabs * '\t'
		for idn in gold_ids:					## test file options
			for key in res_dict:
				if key == m:					## we have the right model
					for item in res_dict[key]:
						if item[0] == idn:		## get right file
							print_l += '\t' + str(item[1])
		print_list.append(print_l)					
	
	printer = [y[1] for y in sorted([[float(z.split()[0]), z] for z in print_list], key = lambda x : x[0])] #sort by number of epochs
	for p in printer: print p
	
	return res_list
	
		
if __name__ == '__main__':
	#ids = ['.seq.amr.restore','.seq.amr.restore.wiki', '.seq.amr.restore.wiki.coref']
	ids = ['.seq.amr.restore','.seq.amr.restore.wiki', '.seq.amr.restore.coref']
	model_type, gold_ids, gold_files, res_dict, dirs_to_check = prepare_data(ids)
	counter = 0
	
	for idx, root in enumerate(dirs_to_check):
		for ident in ids:
			root_fix = args.roots_to_check + root
			res_dict = evaluate(root_fix, ident, model_type[counter], gold_ids, gold_files, res_dict)
			counter += 1
	
	res_list = print_nice_output(res_dict, gold_ids, model_type)
		
