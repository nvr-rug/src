Jonathan May
11/25/15

Instructions for validating AMRs for the Semeval 2016 Task 8 parsing challenge.

I. Eval data format

The eval corpus will have the following format (informal description):

# <Header>

<sentence_1_block>

<sentence_2_block>

...

<sentence_n_block>


<Header> will consist of some line of arbitrary text. In other words,
the header line is a single line starting with "#" and is the first
line of the file.

<sentence_n_block> has the following format:

# ::id <id information>
# ::snt <sentence>
# <other_info_1>
...
# <other_info_n>

In other words, a sentence block consists of a set of lines, each
starting with "#". The id line starts "# ::id " and then has some
arbitrary text.

Importantly, the sentence line starts with "# ::snt ".
***The remainder of the line is the sentence to be parsed***

Additional info lines may follow the sentence line. Each such line
starts with "#". 

At least one blank line separates each sentence block. A sentence
block contains no blank lines. 

This is best demonstrated by the accompanying file "demo.eval" which
is an example valid eval corpus file. Note it consists of three
sentences (the first three of deft-p2-amr-r1-amrs-dev-bolt.txt, which
is part of LDC2015E86_DEFT_Phase_2_AMR_Annotation_R1). 

II. Submission format

The submission should consist of, at a minimum, the following:

<amr_block_1>

<amr_block_2>

...

<amr_block_n>

That is, each AMR should be separated by a blank line. An amr is
represented in penman format, which is fully explained by the
extensive AMR guidelines. AMRs may be take up one or more lines. AMRs
should not contain any empty lines.

AMR blocks may be preceded with comment lines that start with "#". It
is recommended that at a minimum the "# ::id" and "# ::snt" lines from
the eval corpus be preserved, for validation purposes (see below) but
this is not a strict requirement. Unlike in the eval format, empty
lines can appear between comment lines. The only restrictions on empty
lines are:

  1) Successive AMRs *must* contain at least one empty line
  2) No empty line can appear *within* a (multi-line) AMR


II.1: Positive examples

The file 'demo.amr' is a valid submission of demo.eval. It is
generated by the following *nix command:

grep "^# ::snt" demo.eval | cut -d' ' -f3- | python ulfparser.py -o demo.amr

where ulfparser.py is the deterministic input-agnostic amr parser
baseline script that can be found here:
http://alt.qcri.org/semeval2016/task8/data/uploads/ulfparser.py

The file 'demo.amr.rec' is in the recommended format, as it contains
::id and ::snt comment lines.

The file 'demo.amr.minimal' is also an acceptable format. It contains
no comment lines.

The file 'demo.amr.lotsofspace' contains many empty lines in between
AMRs and in between comments, but is still valid

II.2: Negative examples

The file 'demo.amr.bad.multivar' is not valid because, in the first
AMR, the variable 'c' is defined twice.

The file 'demo.amr.bad.parenerror' is not valid because, in the first
AMR, the parentheses do not balance.

The file 'demo.amr.bad.nonewline' is not valid because it does not
contain empty lines between its AMRs.


III. Using the validator

We provide an AMR validator to help you determine if your AMR is in
the right format. The AMR validator does the following:
  * Uses the amr reader that is part of smatch to determine if the AMR
  is smatch-readable
  * Performs a rudimentary balanced-parenthesis check
If an eval corpus is provided, the validator also:
  * Verifies the number of AMRs is the same as the number of sentences
  in the eval corpus
  * If ::snt and ::id comment fields are in the AMR file, verifies the
  sentences and ids are the same.

Validator usage can be determined as follows:

$ python validator.py -h
usage: validator.py [-h] [--infile [INFILE]] [--plainfile [PLAINFILE]]
                    [--outfile [OUTFILE]] [--simple]

AMR validator

optional arguments:
  -h, --help            show this help message and exit
  --infile [INFILE], -i [INFILE]
                        input file (default: <open file '<stdin>', mode 'r' at
                        0x1094130c0>)
  --plainfile [PLAINFILE], -p [PLAINFILE]
                        plain file (default: None)
  --outfile [OUTFILE], -o [OUTFILE]
                        output file (default: <open file '<stdout>', mode 'w'
                        at 0x109413150>)
  --simple, -s          Simple AMR validation. If you're having trouble,
                        enable this to only do paren counting (default: False)


You can simply judge if a file has valid amrs as follows:

$ python validator.py -i demo.amr
3 amrs seen; pass a plainfile in to see how many are expected

As indicated, providing a 'plainfile' (i.e. an eval corpus) will cause
the validator to check for the same number of AMRs as id/snt entries:

$ python validator.py -i demo.amr -p demo.eval
Warning: 3 ids not seen in amr set (maybe you didn't include them? that's not necessarily a problem): Here is one:
# ::id bolt12_64545_0526.1 ::date 2012-12-23T18:47:13 ::annotator SDL-AMR-09 ::preferred
3 amrs expected and seen. Good sign!


Note the warning about ids not seen in amr set. That's because
demo.amr doesn't have ids. If you use the recommended output format,
i.e. include comments with both id and sentence text, you have the
highest reliability:

$ python validator.py -i demo.amr.rec -p demo.eval
3 amrs expected and seen. Good sign!

On the other hand, if you use the minimal amr format you'll get
warnings from the validator but no major warnings:

$ python validator.py -i demo.amr.minimal -p demo.eval
Warning: 3 ids not seen in amr set (maybe you didn't include them? that's not necessarily a problem): Here is one:
# ::id bolt12_64545_0526.1 ::date 2012-12-23T18:47:13 ::annotator SDL-AMR-09 ::preferred
Warning: 3 sents not seen in amr set (maybe you didn't include them? that's not necessarily a problem): Here is one:
# ::snt There are many who have a sense of urgency, quietly watching how things develop,you are dragons coiling, you are tigers crouching, I admire noble-minded patriots.
3 amrs expected and seen. Good sign!

Try the other good amrs (lotsofspace, multiline) to verify they
validate ok.

Major warnings are imporant to pay attention to and fix:

demo.amr.bad.mismatch, for instance, has too many amrs:
$ python validator.py -i demo.amr.bad.mismatch -p demo.eval
...
MAJOR WARNING: 5 amrs seen but 3 expected


here are the other bad files. note that the error reported is not
always the expected error (just like when compiling code)

$ python validator.py -i demo.amr.bad.multivar -p demo.eval
Duplicate variable  c  in parsing AMR
Exception(u"MAJOR WARNING: couldn't build amr out of (s / state-01 :ARG0 (p / person :ARG0-of (h / have-org-role-91 :ARG1 (c / country :name (n / name)) :ARG2 president) :name (n2 / name)) :ARG1 (a / and :op1 (w / want-01 :ARG0 (p2 / person) :ARG1 (d / do-02 :ARG0 p2)) :op2 (p3 / person :mod (c / country :name (n3 / name)))) :time (d2 / date-entity :year 2007)) using smatch code",)

$ python validator.py -i demo.amr.bad.newlineinterrupt -p demo.eval
MAJOR WARNING: parens not balanced in (s / state-01 :ARG0 (p / person :ARG0-of (h / have-org-role-91 :ARG1 (c / country :name (n / name)) :ARG2 president) :name (n2 / name))

$ python validator.py -i demo.amr.bad.nonewline -p demo.eval
Duplicate variable  s  in parsing AMR
Exception(u"MAJOR WARNING: couldn't build amr out of (s / state-01 :ARG0 (p / person :ARG0-of (h / have-org-role-91 :ARG1 (c / country :name (n / name)) :ARG2 president) :name (n2 / name)) :ARG1 (a / and :op1 (w / want-01 :ARG0 (p2 / person) :ARG1 (d / do-02 :ARG0 p2)) :op2 (p3 / person :mod (c2 / country :name (n3 / name)))) :time (d2 / date-entity :year 2007)) (s / state-01 :ARG0 (p / person :ARG0-of (h / have-org-role-91 :ARG1 (c / country :name (n / name)) :ARG2 president) :name (n2 / name)) :ARG1 (a / and :op1 (w / want-01 :ARG0 (p2 / person) :ARG1 (d / do-02 :ARG0 p2)) :op2 (p3 / person :mod (c2 / country :name (n3 / name)))) :time (d2 / date-entity :year 2007)) (s / state-01 :ARG0 (p / person :ARG0-of (h / have-org-role-91 :ARG1 (c / country :name (n / name)) :ARG2 president) :name (n2 / name)) :ARG1 (a / and :op1 (w / want-01 :ARG0 (p2 / person) :ARG1 (d / do-02 :ARG0 p2)) :op2 (p3 / person :mod (c2 / country :name (n3 / name)))) :time (d2 / date-entity :year 2007)) using smatch code",)

$ python validator.py -i demo.amr.bad.parenerror -p demo.eval
MAJOR WARNING: parens not balanced in (s / state-01 :ARG0 (p / person :ARG0-of (h / have-org-role-91 :ARG1 (c / country :name (n / name)) :ARG2 president) :name (n2 / name)) :ARG1 (a / and :op1 (w / want-01 :ARG0 (p2 / person) :ARG1 (d / do-02 :ARG0 p2)) :op2 (p3 / person :mod (c2 / country :name (n3 / name)))) :time (d2 / date-entity :year 2007)

And here's what happens when you accidentally score the corpus file.

$ python validator.py -i demo.eval -p demo.eval
MAJOR WARNING: 0 amrs seen but 3 expected

